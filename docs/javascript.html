<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.23.0">
    <meta name="project" content="geometrics v0.1.0">

    <title>Javascript — geometrics v0.1.0</title>
    <link rel="stylesheet" href="dist/elixir-9f91ebe876dc01d67920.css" />

    <script src="dist/sidebar_items-a7c3bb4b95.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-60a0c9f10e9e52eae31f.js"></script>


  </head>
  <body data-type="extras">
    <script>try { if(localStorage.getItem('night-mode') === 'true') document.body.className += ' night-mode'; } catch (e) { }</script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" id="search-list" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="overview.html" class="sidebar-projectName">
geometrics
      </a>
      <strong class="sidebar-projectVersion">
        v0.1.0
      </strong>
    </div>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">Pages</a></li>

      <li><a id="modules-list" href="#full-list">Modules</a></li>


      <li><a id="tasks-list" href="#full-list">Mix Tasks</a></li>

  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>Javascript</h1><p>Geometrics provides a few hooks for tracing front-end Javascript along with back-end Elixir. This demonstrates the
premise of distributed tracing—in a single trace, one could potentially see the timings of a user's browser page load,
then connection to LiveView, along with each event that transpires.</p><h2 id="tracing-across-stack-boundaries" class="section-heading">
  <a href="#tracing-across-stack-boundaries" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Tracing across stack boundaries
</h2>
<p>In order to tie the backend tracing context to front end events, you must provide a set of meta tags in your root
layout.</p><pre><code class=".eex">&lt;%= Geometrics.Phoenix.View.meta_tags() %&gt;</code></pre><p>This will create two <code class="inline">meta</code> tags:</p><ul><li>A tag with the name <code class="inline">traceparent</code> that contains a unique identifier used by OpenTelemetry to tie traces together. The
naming for this meta tag arises from a recent W3C proposal around distributed tracing. It proposes a standard format
for headers that lets you identify traces across services. If you're curious to read more about it, check out the
proposal <a href="https://www.w3.org/TR/trace-context/#problem-statement">here</a>).</li><li>A tag with the name <code class="inline">collector_endpoint</code> whose value is the endpoint url that the frontend will send telemetry events
to.</li></ul><h2 id="collecting-traces" class="section-heading">
  <a href="#collecting-traces" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Collecting traces
</h2>
<p>In order aggregate and export trace events, the frontend needs to speak with a public endpoint separate from your
Phoenix backend. This endpoint is a running server called
an <a href="https://github.com/open-telemetry/opentelemetry-collector">opentelemetry-collector</a>. Its main purpose is to receive
requests containing trace information to buffer and export traces to visualization services like Honeycomb.</p><h2 id="setup" class="section-heading">
  <a href="#setup" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Setup
</h2>
<p>To use Geometrics' included javascript, you must add it to your <code class="inline">package.json</code>:</p><pre><code class=".json">  &quot;dependencies&quot;: {
    ...
    &quot;geometrics&quot;: &quot;file:../../geometrics&quot;,
    ...
  },
</code></pre><p>Then run <code class="inline">npm install</code></p><h2 id="usage" class="section-heading">
  <a href="#usage" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Usage
</h2>
<p>To capture spans, you can wrap whatever block of code you wish to capture in a <code class="inline">withSpan</code>. This function allows you to
pass a name for the span, as well as a function that will wrap the code for the span. This function will also receive a
javascript object which represents the span that is being created. In the example below we use this object to pass the
context of our frontend event to our LiveView backend via param.</p><pre><code class=".js">import {withSpan, initTracer} from &quot;geometrics&quot;

initTracer({
  serviceName: 'frontend',
  logToConsole: true
})

const liveSocket = withSpan(&quot;liveSocket.connect()&quot;, (span) =&gt; {
  const csrfToken = document.querySelector(&quot;meta[name='csrf-token']&quot;).getAttribute(&quot;content&quot;)
  const options = {
    params: {
      _csrf_token: csrfToken,
      traceContext: span.context()
    }
  }
  const liveSocket = new LiveSocket(&quot;/live&quot;, Socket, options)
  liveSocket.connect()

  return liveSocket
})</code></pre><p>Note that we pass the <code class="inline">span.context()</code> in the socket connection params as <code class="inline">traceContext</code>. We pick up this context on the
backend and use it to tie the frontend span with the trace context in the backend.</p><p>At the moment, it is only possible to record synchronous behavior executed in the context of a <code class="inline">withSpan</code>.</p>
      <footer class="footer">
        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.23.0) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
