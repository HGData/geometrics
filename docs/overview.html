<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.24.2">
    <meta name="project" content="geometrics v0.2.0">

    <title>Overview — geometrics v0.2.0</title>
    <link rel="stylesheet" href="dist/elixir-a172fe91e725dcb259e2.css" />

    <script src="dist/sidebar_items-27acd1ba18.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-f27ff079945e43879c46.js"></script>


  </head>
  <body data-type="extras">
    <script>

      try {
        if (localStorage.getItem('night-mode') === 'true') {
          document.body.classList.add('night-mode');
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="overview.html" class="sidebar-projectName">
geometrics
      </a>
      <strong class="sidebar-projectVersion">
        v0.2.0
      </strong>
    </div>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list-link" href="#full-list">Pages</a></li>

      <li><a id="modules-list-link" href="#full-list">Modules</a></li>


      <li><a id="tasks-list-link" href="#full-list">Mix Tasks</a></li>

  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>Overview</h1><p>This library attempts to encode opinions and documentation for instrumenting an application
with traces. It is in essence a wrapper for OpenTelemetry, which is a cross-language and
platform-agnostic specification for creating application traces and exporting them into tools
that can later visualize the traces.</p><p>At the time of writing, OpenTelemetry has just reached 1.0 of its specification, and many
details of how to implement it are lightly documented. OpenTelemetry is the joining of two
large open initiatives, OpenCensus and OpenTracing.</p><h2 id="application-tracing" class="section-heading">
  <a href="#application-tracing" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Application Tracing
</h2>
<p>What the heck is application tracing?</p><p>Fundamentally, it is instrumenting code, specifically such that the execution of blocks of code
can be later visualized. These <code class="inline">spans</code> of code execution may be nested within a parent <code class="inline">span</code>,
each span including timing data and attributes. The combination of all of the spans for a
specific block of time represent a <code class="inline">trace</code>.</p><p>In terms of OpenTelemetry, every <code class="inline">trace</code> should include a single root <code class="inline">span</code>, within which there
may be N trees of child spans. Parent spans may or may not be closed before their children—in a
distributed system with async processing, a trace may span multiple systems, with requests
completing even though other process complete actions initiated by the request.</p><p>Let us take, as an example, an HTTP request to a Phoenix controller.</p><p>The HTTP request consists of a request and a response. At some point in the request, a span may
be opened. Since this is the first span, representing the root, a <code class="inline">trace-id</code> is generated. Inside
the controller action, one or more database queries may be made (each wrapped in its own span,
but inheriting the <code class="inline">trace-id</code>), after which the renderer executes and a response is sent to the
client. After the response is sent, callback functions may be executed before the <code class="inline">cowboy</code>
process exits. Some time either before or after the callbacks, the root span is ended.</p><p>This might be represented by the following time-based visualization:</p><pre><code class="makeup elixir"><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nc">GET</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">--</span><span class="o">-</span><span class="w"> </span><span class="o">|</span><span class="w">
   </span><span class="o">|</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w">
                 </span><span class="o">|</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w">
                                  </span><span class="o">|</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w">
                                                    </span><span class="o">|</span><span class="w"> </span><span class="n">render</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="o">|</span><span class="w">
                                                                 </span><span class="o">|</span><span class="w"> </span><span class="n">response</span><span class="w"> </span><span class="o">|</span><span class="w">
                                                                        </span><span class="o">|</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w">
                                                                          </span><span class="o">|</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">|</span></code></pre><h2 id="distributed-tracing-ie-propagation" class="section-heading">
  <a href="#distributed-tracing-ie-propagation" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Distributed Tracing (ie Propagation)
</h2>
<p>A trace may involve multiple applications, or multiple runtimes. For instance, an HTTP request
may generate asynchronous jobs in a tool such as Oban. A web application may involve browser-based
Javascript as well as an Elixir backend.</p><p>For this reason a <code class="inline">trace-id</code> may be <code class="inline">propagated</code> between different systems. There are different
ways this could be implemented, but OpenTelemetry attempts to provide mechanisms that can be
configured per-application (so that every span touch point does not need to manually execute
the correct propagators).</p><p>Two popular mechanisms of propagating traces between systems are the
(W3C Trace-Context)[<a href="https://www.w3.org/TR/trace-context/]">https://www.w3.org/TR/trace-context/]</a> and
(B3 Propagation)[<a href="https://github.com/openzipkin/b3-propagation].">https://github.com/openzipkin/b3-propagation].</a> The former defines a single
format for encoding <code class="inline">trace-id</code>, <code class="inline">span-id</code>, and trace-specific flags in a <code class="inline">traceparent</code> header.
The latter is implemented by many open source trace aggregators.</p><p>Geometrics does two things to propagate traces from Phoenix to Javascript. First, there is a
plug that sets things from the current trace onto the <code class="inline">conn</code>, in private attributes as well as
response headers. Using the provided Phoenix view helpers in the root layout also writes out
configuration via meta tags that the javascript can hook into. Propagating the trace back to
other contexts (XHTML requests, websockets, live view, etc) may require some manual integration.
Theoretically, propagation mechanisms can be introduced that do everything automatically—in
practice this may not be possible (for instance, with Phoenix Channel/LiveView javascript which
does not not provide automatic hooks to alter connection headers).</p><h2 id="tracing-vs-metrics" class="section-heading">
  <a href="#tracing-vs-metrics" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Tracing vs Metrics
</h2>
<p>Many of us are familiar with the concept of metrics. How metrics overlaps with tracing may not
be clear, however.</p><p>A metric tends to be an individual data point encapsulating some event at some point in time. When
large amounts of metrics are produced, many systems begin aggregating the metrics. At any point in
time, a tool for visualizing application metrics may only retain computed statistics and aggregations
(sums, 95th percentile, etc).</p><p>Tracing takes a different approach, which is to capture correlated runtime data across spans of time,
and send raw data to backend systems. If large amounts of traces are produced, they may be sampled
at some rate to filter the traces that are actually sent.</p><p>Metrics tend to aggregate before exporting. Tracing sends as much data as possible, and relies on
exporting to more sophisticated back-ends that can aggregate and analyze the aggregate traces on the
fly.</p><h2 id="exporting-traces" class="section-heading">
  <a href="#exporting-traces" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Exporting traces
</h2>
<p>One thing that is important about OpenTelemetry is that it provides a specification for implementing
application tracing across multiple languages, a normalized set of attributes for different types of
traces (HTTP requests vs database queries, for example), and a vendor-agnostic protocol for 
exporting span traces to various 3rd-party tracing services (Honeycomb, Jaeger, Zipkin).</p><p>This means that a team can instrument their applications in one way, and swap out the service(s) used to analyze traces
if needed. In other words, you can choose to instrument your frontend and backend respectively with <code class="inline">opentelemetry-js</code>
and <code class="inline">opentelemetry-erlang</code>, and have both those libraries report data to Honeycomb using a consistent standard. The way
this was achieved was by standardizing that all OpenTelemetry language implementations must be able to communicate with
a running agent called an <a href="https://github.com/open-telemetry/opentelemetry-collector">OpenTelemetry collector</a> over HTTP.</p><p>The <a href="https://github.com/open-telemetry/opentelemetry-collector">OpenTelemetry collector agent</a> is used
to collect traces using the vendor-agnostic protocol, then forward the traces to a 3rd party tracing service. This
allows applications to export traces via a single mechanism, without having to care what happens later.</p><p>The diagram below illustrates how this looks.</p><p><img src="assets/OpenTelemetry Exporter Diagram.png" alt="OpenTelemetry Exporter Diagram"/></p><h2 id="opentelemetry-gotchas" class="section-heading">
  <a href="#opentelemetry-gotchas" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  OpenTelemetry gotchas
</h2>
<ul><li>Spans are only valid if they are ended, giving them a duration.</li><li>Spans are only exported if they are valid.</li><li>Timeout errors in Elixir/Erlang usually signal process exits, rather than
raising exceptions.</li><li><code class="inline">:telemetry</code> helpers rescue/reraise exceptions, but do not catch exits.</li><li>Helper libraries like <a href="https://hexdocs.pm/opentelemetry_phoenix/1.0.0-rc.2/OpentelemetryPhoenix.html"><code class="inline">OpentelemetryPhoenix</code></a> and <a href="https://hexdocs.pm/opentelemetry_ecto/1.0.0-rc.1/OpentelemetryEcto.html"><code class="inline">OpentelemetryEcto</code></a> hook
into <code class="inline">:telemetry</code>, since they are unable to alter Phoenix/Ecto runtime code
to introduce <a href="https://hexdocs.pm/opentelemetry_api/1.0.0-rc.2/OpenTelemetry.html"><code class="inline">OpenTelemetry</code></a>-specific helpers.</li><li>Ergo... an overloaded system that begins timing out in GenServer calls or
database queries may lose the most important traces, ie those associated with
the timeouts. See the <a href="phoenix.html">Phoenix + Ecto</a> page for more info.</li></ul>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="api-reference.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
API Reference
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="installation.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Installation
        </span>
      </a>

  </div>
</div>

      <footer class="footer">
        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.24.2) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
